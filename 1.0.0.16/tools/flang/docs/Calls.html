

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Representation of Fortran function calls &#8212; The Flang Compiler</title>
    <link rel="stylesheet" href="_static/llvm-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/llvm.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Implementation of CHARACTER types in f18" href="Character.html" />
    <link rel="prev" title="Runtime Descriptors" href="RuntimeDescriptor.html" />
<style type="text/css">
  table.right { float: right; margin-left: 20px; }
  table.right td { border: 1px solid #ccc; }
</style>

  </head><body>
<div class="logo">
  <a href="index.html">
    <img src="_static/logo.png"
         alt="LLVM Logo" width="250" height="88"/></a>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="Character.html" title="Implementation of CHARACTER types in f18"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="RuntimeDescriptor.html" title="Runtime Descriptors"
             accesskey="P">previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">

<h3>Documentation</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/master/flang/README.md#getting-started">Getting Started</a></li>
</ul>

<h3>Getting Involved</h3>
<! TODO: Point links to website(flang.llvm.org) and not github once webpage comes up.>
<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/blob/master/flang/docs/GettingInvolved.md#mailing-lists">Mailing Lists</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/master/flang/docs/GettingInvolved.md#chat">Slack</a></li>
    <li><a href="https://github.com/llvm/llvm-project/blob/master/flang/docs/GettingInvolved.md#calls">Calls</a></li>
</ul>

<h3>Additional Links</h3>

<ul class="want-points">
    <li><a href="https://github.com/llvm/llvm-project/tree/master/flang/">Github Repository</a></li>
    <li><a href="https://bugs.llvm.org/">Bug Reports</a></li>
    <li><a href="https://reviews.llvm.org/">Code Review</a></li>
<! TODO: Have the bots setup first>
    <li><a href="#">Doxygen API</a></li>
</ul>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <!--===- docs/Calls.md<p>Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
See https://llvm.org/LICENSE.txt for license information.
SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception</p>
<p>–&gt;</p>
<div class="section" id="representation-of-fortran-function-calls">
<span id="representation-of-fortran-function-calls"></span><h1>Representation of Fortran function calls<a class="headerlink" href="#representation-of-fortran-function-calls" title="Permalink to this headline">¶</a></h1>
<div class="section" id="procedure-reference-implementation-protocol">
<span id="procedure-reference-implementation-protocol"></span><h2>Procedure reference implementation protocol<a class="headerlink" href="#procedure-reference-implementation-protocol" title="Permalink to this headline">¶</a></h2>
<p>Fortran function and subroutine references are complicated.
This document attempts to collect the requirements imposed by the 2018
standard (and legacy extensions) on programs and implementations, work
through the implications of the various features, and propose both a
runtime model and a compiler design.</p>
<p>All section, requirement, and constraint numbers herein pertain to
the Fortran 2018 standard.</p>
<p>This note does not consider calls to intrinsic procedures, statement
functions, or calls to internal runtime support library routines.</p>
</div>
<div class="section" id="quick-review-of-terminology">
<span id="quick-review-of-terminology"></span><h2>Quick review of terminology<a class="headerlink" href="#quick-review-of-terminology" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>A <em>dummy argument</em> is a function or subroutine parameter.
It is <em>associated</em> with an <em>effective argument</em> at each call
to the procedure.</li>
<li>The <em>shape</em> of an array is a vector containing its extent (size)
on each dimension; the <em>rank</em> of an array is the number of its
dimensions (i.e., the shape of its shape).
The absolute values of the lower and upper bounds of the dimensions
of an array are not part of its shape, just their difference (plus 1).</li>
<li>An <em>explicit-shape</em> array has all of its bounds specified; lower
bounds default to 1.  These can be passed by with a single address
and their contents are contiguous.</li>
<li>An <em>assumed-size</em> array is an explicit-shape array with <code class="docutils literal notranslate"><span class="pre">*</span></code> as its
final dimension, which is the most-significant one in Fortran
and whose value does not affect indexed address calculations.</li>
<li>A <em>deferred-shape</em> array (<code class="docutils literal notranslate"><span class="pre">DIMENSION::A(:)</span></code>) is a <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> or <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>.
<code class="docutils literal notranslate"><span class="pre">POINTER</span></code> target data might not be contiguous.</li>
<li>An <em>assumed-shape</em> (not size!) array (<code class="docutils literal notranslate"><span class="pre">DIMENSION::A(:)</span></code>) is a dummy argument
that is neither <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> nor <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>; its lower bounds can be set
by the procedure that receives them (defaulting to 1), and its
upper bounds are functions of the lower bounds and the extents of
dimensions in the <em>shape</em> of the effective argument.</li>
<li>An <em>assumed-length</em> <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> dummy argument
takes its length from the effective argument.</li>
<li>An <em>assumed-length</em> <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> <em>result</em> of an external function (C721)
has its length determined by its eventual declaration in a calling scope.</li>
<li>An <em>assumed-rank</em> <code class="docutils literal notranslate"><span class="pre">DIMENSION::A(..)</span></code> dummy argument array has an unknown
number of dimensions.</li>
<li>A <em>polymorphic</em> <code class="docutils literal notranslate"><span class="pre">CLASS(t)</span></code> dummy argument, <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, or <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>
has a specific derived type or some extension of that type.
An <em>unlimited polymorphic</em> <code class="docutils literal notranslate"><span class="pre">CLASS(*)</span></code> object can have any
intrinsic or derived type.</li>
<li><em>Interoperable</em> <code class="docutils literal notranslate"><span class="pre">BIND(C)</span></code> procedures are written in C or callable from C.</li>
</ul>
</div>
<div class="section" id="interfaces">
<span id="interfaces"></span><h2>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h2>
<p>Referenced procedures may or may not have declared interfaces
available to their call sites.</p>
<p>Procedures with some post-Fortran ‘77 features <em>require</em> an
explicit interface to be called (15.4.2.2) or even passed (4.3.4(5)):</p>
<ul class="simple">
<li>use of argument keywords in a call</li>
<li>procedures that are <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> or <code class="docutils literal notranslate"><span class="pre">BIND(C)</span></code></li>
<li>procedures that are required to be <code class="docutils literal notranslate"><span class="pre">PURE</span></code> due to the context of the call
(specification expression, <code class="docutils literal notranslate"><span class="pre">DO</span> <span class="pre">CONCURRENT</span></code>, <code class="docutils literal notranslate"><span class="pre">FORALL</span></code>)</li>
<li>dummy arguments with these attributes: <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>,
<code class="docutils literal notranslate"><span class="pre">VALUE</span></code>, <code class="docutils literal notranslate"><span class="pre">TARGET</span></code>, <code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code>, <code class="docutils literal notranslate"><span class="pre">ASYNCHRONOUS</span></code>, <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code>,
and, as a consequence of limitations on its use, <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code>;
<code class="docutils literal notranslate"><span class="pre">INTENT()</span></code>, however, does <em>not</em> require an explicit interface</li>
<li>dummy arguments that are coarrays</li>
<li>dummy arguments that are assumed-shape or assumed-rank arrays</li>
<li>dummy arguments with parameterized derived types</li>
<li>dummy arguments that are polymorphic</li>
<li>function result that is an array</li>
<li>function result that is <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> or <code class="docutils literal notranslate"><span class="pre">POINTER</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> function result whose length is neither constant
nor assumed</li>
<li>derived type function result with <code class="docutils literal notranslate"><span class="pre">LEN</span></code> type parameter value that is
not constant
(note that result derived type parameters cannot be assumed (C795))</li>
</ul>
<p>Module procedures, internal procedures, procedure pointers,
type-bound procedures, and recursive references by a procedure to itself
always have explicit interfaces.
(Consequently, they cannot be assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> functions;
conveniently, assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> functions are prohibited from
recursion (15.6.2.1(3))).</p>
<p>Other uses of procedures besides calls may also require explicit interfaces,
such as procedure pointer assignment, type-bound procedure bindings, &amp;c.</p>
<p>Note that non-parameterized monomorphic derived type arguments do
<em>not</em> by themselves require the use of an explicit interface.
However, dummy arguments with any derived type parameters <em>do</em>
require an explicit interface, even if they are all <code class="docutils literal notranslate"><span class="pre">KIND</span></code> type
parameters.</p>
<p>15.5.2.9(2) explicitly allows an assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> function
to be passed as an actual argument to an explicit-length dummy;
this has implications for calls to character-valued dummy functions
and function pointers.
(In the scopes that reference <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> functions, they must have
visible definitions with explicit result lengths.)</p>
<div class="section" id="implicit-interfaces">
<span id="implicit-interfaces"></span><h3>Implicit interfaces<a class="headerlink" href="#implicit-interfaces" title="Permalink to this headline">¶</a></h3>
<p>In the absence of any characteristic or context that <em>requires</em> an
explicit interface (see above), an external function or subroutine (R503)
or <code class="docutils literal notranslate"><span class="pre">ENTRY</span></code> (R1541) can be called directly or indirectly via its implicit interface.
Each of the arguments can be passed as a simple address, including
dummy procedures.
Procedures that <em>can</em> be called via an implicit interface can
undergo more thorough checking
by semantics when an explicit interface for them exists, but they must be
compiled as if all calls to them were through the implicit interface.
This note will mention special handling for procedures that are exposed
to the possibility of being called with an implicit interface as <em>F77ish</em> procedures
below; this is of course not standard terminology.</p>
<p>Internal and module subprograms that are ever passed as arguments &amp;/or
assigned as targets of procedure pointers may be F77ish.</p>
<p>Every F77ish procedure can and must be distiguished at compilation time.
Such procedures should respect the external naming conventions (when external)
and any legacy ABI used for Fortran ‘77 programs on the target architecture,
so that portable libraries can be compiled
and used by distinct implementations (and their versions)
of Fortran.</p>
<p>Note that F77ish functions still have known result types, possibly by means
of implicit typing of their names.
They can also be <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> assumed-length character functions.</p>
<p>In other words: these F77sh procedures that do not require the use of an explicit
interface and that can possibly be referenced, directly or indirectly,
with implicit interfaces are limited to argument lists that comprise
only the addresses of effective arguments and the length of a <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> function result
(when there is one), and they can return only scalar values with constant
type parameter values.
None of their arguments or results need be (or can be) implemented
with descriptors,
and any internal procedures passed to them as arguments must be
simple addresses of non-internal subprograms or trampolines for
internal procedures.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">INTENT</span></code> attribute does not, by itself,
require the use of explicit interface; neither does the use of a dummy
procedure (implicit or explicit in their interfaces).
So the analyis of calls to F77ish procedures must allow for the
invisible use of <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>.</p>
</div>
</div>
<div class="section" id="protocol-overview">
<span id="protocol-overview"></span><h2>Protocol overview<a class="headerlink" href="#protocol-overview" title="Permalink to this headline">¶</a></h2>
<p>Here is a summary script of all of the actions that may need to be taken
by the calling procedure and its referenced procedure to effect
the call, entry, exit, and return steps of the procedure reference
protocol.
The order of these steps is not particularly strict, and we have
some design alternatives that are explored further below.</p>
<div class="section" id="before-the-call">
<span id="before-the-call"></span><h3>Before the call:<a class="headerlink" href="#before-the-call" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li>Compute &amp;/or copy into temporary storage the values of
some effective argument expressions and designators (see below).</li>
<li>Create and populate descriptors for arguments that use them
(see below).</li>
<li>Possibly allocate function result storage,
when its size can be known by all callers; function results that are
neither <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> nor <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> must have explicit shapes (C816).</li>
<li>Create and populate a descriptor for the function result, if it
needs one (deferred-shape/-length <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, any <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>,
derived type with non-constant length parameters, &amp;c.).</li>
<li>Capture the values of host-escaping local objects in memory;
package them into single address (for calls to internal procedures &amp;
for calls that pass internal procedures as arguments).</li>
<li>Resolve the target procedure’s polymorphic binding, if any.</li>
<li>Marshal effective argument addresses (or values for <code class="docutils literal notranslate"><span class="pre">%VAL()</span></code> and some
discretionary <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> arguments) into registers.</li>
<li>Marshal <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> argument lengths in additional value arguments for
<code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> effective arguments not passed via descriptors.
These lengths must be 64-bit integers.</li>
<li>Marshal an extra argument for the length of a <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> function
result if the function is F77ish.</li>
<li>Marshal an extra argument for the function result’s descriptor,
if it needs one.</li>
<li>Set the “host instance” (static link) register when calling an internal
procedure from its host or another internal procedure, a procedure pointer,
or dummy procedure (when it has a descriptor).</li>
<li>Jump.</li>
</ol>
</div>
<div class="section" id="on-entry">
<span id="on-entry"></span><h3>On entry:<a class="headerlink" href="#on-entry" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li>For subprograms with alternate <code class="docutils literal notranslate"><span class="pre">ENTRY</span></code> points: shuffle <code class="docutils literal notranslate"><span class="pre">ENTRY</span></code> dummy arguments
set a compiler-generated variable to identify the alternate entry point,
and jump to the common entry point for common processing and a <code class="docutils literal notranslate"><span class="pre">switch()</span></code>
to the statement after the <code class="docutils literal notranslate"><span class="pre">ENTRY</span></code>.</li>
<li>Capture <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> argument &amp;/or assumed-length result length values.</li>
<li>Complete <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> copying if this step will not always be done
by the caller (as I think it should be).</li>
<li>Finalize &amp;/or re-initialize <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> non-pointer
effective arguments (see below).</li>
<li>For interoperable procedures called from C: compact discontiguous
dummy argument values when necessary (<code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> &amp;/or
explicit-shape/assumed-size arrays of assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code>).</li>
<li>Optionally compact assumed-shape arguments for contiguity on one
or more leading dimensions to improve SIMD vectorization, if not
<code class="docutils literal notranslate"><span class="pre">TARGET</span></code> and not already sufficiently contiguous.
(PGI does this in the caller, whether the callee needs it or not.)</li>
<li>Complete allocation of function result storage, if that has
not been done by the caller.</li>
<li>Initialize components of derived type local variables,
including the function result.</li>
</ol>
<p>Execute the callee, populating the function result or selecting
the subroutine’s alternate return.</p>
</div>
<div class="section" id="on-exit">
<span id="on-exit"></span><h3>On exit:<a class="headerlink" href="#on-exit" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li>Clean up local scope (finalization, deallocation)</li>
<li>Deallocate <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> argument temporaries.
(But don’t finalize them; see 7.5.6.3(3)).</li>
<li>Replace any assumed-shape argument data that were compacted on
entry for contiguity when the data were possibly
modified across the call (never when <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> or <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>).</li>
<li>Identify alternate <code class="docutils literal notranslate"><span class="pre">RETURN</span></code> to caller.</li>
<li>Marshal results.</li>
<li>Jump</li>
</ol>
</div>
<div class="section" id="on-return-to-the-caller">
<span id="on-return-to-the-caller"></span><h3>On return to the caller:<a class="headerlink" href="#on-return-to-the-caller" title="Permalink to this headline">¶</a></h3>
<ol class="simple">
<li>Save the result registers, if any.</li>
<li>Copy effective argument array designator data that was copied into
a temporary back into its original storage (see below).</li>
<li>Complete deallocation of effective argument temporaries (not <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>).</li>
<li>Reload definable host-escaping local objects from memory, if they
were saved to memory by the host before the call.</li>
<li><code class="docutils literal notranslate"><span class="pre">GO</span> <span class="pre">TO</span></code> alternate return, if any.</li>
<li>Use the function result in an expression.</li>
<li>Eventually, finalize &amp;/or deallocate the function result.</li>
</ol>
<p>(I’ve omitted some obvious steps, like preserving/restoring callee-saved
registers on entry/exit, dealing with caller-saved registers before/after
calls, and architecture-dependent ABI requirements.)</p>
</div>
</div>
<div class="section" id="the-messy-details">
<span id="the-messy-details"></span><h2>The messy details<a class="headerlink" href="#the-messy-details" title="Permalink to this headline">¶</a></h2>
<div class="section" id="copying-effective-argument-values-into-temporary-storage">
<span id="copying-effective-argument-values-into-temporary-storage"></span><h3>Copying effective argument values into temporary storage<a class="headerlink" href="#copying-effective-argument-values-into-temporary-storage" title="Permalink to this headline">¶</a></h3>
<p>There are several conditions that require the compiler to generate
code that allocates and populates temporary storage for an actual
argument.</p>
<p>First, effective arguments that are expressions, not designators, obviously
need to be computed and captured into memory in order to be passed
by reference.
This includes parenthesized designators like <code class="docutils literal notranslate"><span class="pre">(X)</span></code>, which are
expressions in Fortran, as an important special case.
(This case also technically includes unparenthesized constants,
but those are better implemented by passing addresses in read-only
memory.)
The dummy argument cannot be known to have <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> or
<code class="docutils literal notranslate"><span class="pre">INTENT(IN</span> <span class="pre">OUT)</span></code>.</p>
<p>Small scalar or elemental <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> arguments may be passed in registers,
as should arguments wrapped in the legacy VMS <code class="docutils literal notranslate"><span class="pre">%VAL()</span></code> notation.
Multiple elemental <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> arguments might be packed into SIMD registers.</p>
<p>Effective arguments that are designators, not expressions, must also
be copied into temporaries in the following situations.</p>
<ol class="simple">
<li>Coindexed objects need to be copied into the local image.
This can get very involved if they contain <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>
components, which also need to be copied, along with their
<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> components, and may be best implemented with a runtime
library routine working off a description of the type.</li>
<li>Effective arguments associated with dummies with the <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>
attribute need to be copied; this can be done on either
side of the call, but there are optimization opportunities
available when the caller’s side bears the responsibility.</li>
<li>In non-elemental calls, the values of array sections with
vector-valued subscripts need to be gathered into temporaries.
These effective arguments are not definable, and they are not allowed to
be associated with non-<code class="docutils literal notranslate"><span class="pre">VALUE</span></code> dummy arguments with the attributes
<code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>, <code class="docutils literal notranslate"><span class="pre">INTENT(IN</span> <span class="pre">OUT)</span></code>, <code class="docutils literal notranslate"><span class="pre">ASYNCHRONOUS</span></code>, or <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code>
(15.5.2.4(21)); <code class="docutils literal notranslate"><span class="pre">INTENT()</span></code> can’t always be checked.</li>
<li>Non-simply-contiguous (9.5.4) arrays being passed to non-<code class="docutils literal notranslate"><span class="pre">POINTER</span></code>
dummy arguments that must be contiguous (due to a <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code>
attribute, or not being assumed-shape or assumed-rank; this
is always the case for F77ish procedures).
This should be a runtime decision, so that effective arguments
that turn out to be contiguous can be passed cheaply.
This rule does not apply to coarray dummies, whose effective arguments
are required to be simply contiguous when this rule would otherwise
force the use of a temporary (15.5.2.8); neither does it apply
to <code class="docutils literal notranslate"><span class="pre">ASYNCHRONOUS</span></code> and <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code> effective arguments, which are
disallowed when copies would be necessary (C1538 - C1540).
<em>Only temporaries created by this contiguity requirement are
candidates for being copied back to the original variable after
the call</em> (see below).</li>
</ol>
<p>Fortran requires (18.3.6(5)) that calls to interoperable procedures
with dummy argument arrays with contiguity requirements
handle the compaction of discontiguous data <em>in the Fortran callee</em>,
at least when called from C.
And discontiguous data must be compacted on the <em>caller’s</em> side
when passed from Fortran to C (18.3.6(6)).</p>
<p>We could perform all argument compaction (discretionary or
required) in the callee, but there are many cases where the
compiler knows that the effective argument data are contiguous
when compiling the caller (a temporary is needed for other reasons,
or the effective argument is simply contiguous) and a run-time test for
discontiguity in the callee can be avoided by using a caller-compaction
convention when we have the freedom to choose.</p>
<p>While we are unlikely to want to <em>needlessly</em> use a temporary for
an effective argument that does not require one for any of these
reasons above, we are specifically disallowed from doing so
by the standard in cases where pointers to the original target
data are required to be valid across the call (15.5.2.4(9-10)).
In particular, compaction of assumed-shape arrays for discretionary
contiguity on the leading dimension to ease SIMD vectorization
cannot be done safely for <code class="docutils literal notranslate"><span class="pre">TARGET</span></code> dummies without <code class="docutils literal notranslate"><span class="pre">VALUE</span></code>.</p>
<p>Effective arguments associated with known <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> dummies that
require allocation of a temporary – and this can only be for reasons of
contiguity – don’t have to populate it, but they do have to perform
minimal initialization of any <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> components so that
the runtime doesn’t crash when the callee finalizes and deallocates
them.
<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> coarrays are prohibited from being affected by <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>
(see C846).
Note that calls to implicit interfaces must conservatively allow
for the use of <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> by the callee.</p>
<p>Except for <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> and known <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> dummy arguments, the original
contents of local designators that have been compacted into temporaries
could optionally have their <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> components invalidated
across the call as an aid to debugging.</p>
<p>Except for <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> and known <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> dummy arguments, the contents of
the temporary storage will be copied back into the effective argument
designator after control returns from the procedure, and it may be necessary
to preserve addresses (or the values of subscripts and cosubscripts
needed to recalculate them) of the effective argument designator, or its
elements, in additional temporary storage if they can’t be safely or
quickly recomputed after the call.</p>
</div>
<div class="section" id="intent-out-preparation">
<span id="intent-out-preparation"></span><h3><code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> preparation<a class="headerlink" href="#intent-out-preparation" title="Permalink to this headline">¶</a></h3>
<p>Effective arguments that are associated with <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>
dummy arguments are required to be definable.
This cannot always be checked, as the use of <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>
does not by itself mandate the use of an explicit interface.</p>
<p><code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> arguments are finalized (as if) on entry to the called
procedure.  In particular, in calls to elemental procedures,
the elements of an array are finalized by a scalar or elemental
<code class="docutils literal notranslate"><span class="pre">FINAL</span></code> procedure (7.5.6.3(7)).</p>
<p>Derived type components that are <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> are finalized
and deallocated; they are prohibited from being coarrays.
Components with initializers are (re)initialized.</p>
<p>The preparation of effective arguments for <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> could be
done on either side of the call.  If the preparation is
done by the caller, there is an optimization opportunity
in situations where unmodified incoming <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> dummy
arguments whose types lack <code class="docutils literal notranslate"><span class="pre">FINAL</span></code> procedures are being passed
onward as outgoing <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> arguments.</p>
</div>
<div class="section" id="arguments-and-function-results-requiring-descriptors">
<span id="arguments-and-function-results-requiring-descriptors"></span><h3>Arguments and function results requiring descriptors<a class="headerlink" href="#arguments-and-function-results-requiring-descriptors" title="Permalink to this headline">¶</a></h3>
<p>Dummy arguments are represented with the addresses of new descriptors
when they have any of the following characteristics:</p>
<ol class="simple">
<li>assumed-shape array (<code class="docutils literal notranslate"><span class="pre">DIMENSION::A(:)</span></code>)</li>
<li>assumed-rank array (<code class="docutils literal notranslate"><span class="pre">DIMENSION::A(..)</span></code>)</li>
<li>parameterized derived type with assumed <code class="docutils literal notranslate"><span class="pre">LEN</span></code> parameters</li>
<li>polymorphic (<code class="docutils literal notranslate"><span class="pre">CLASS(T)</span></code>, <code class="docutils literal notranslate"><span class="pre">CLASS(*)</span></code>)</li>
<li>assumed-type (<code class="docutils literal notranslate"><span class="pre">TYPE(*)</span></code>)</li>
<li>coarray dummy argument</li>
<li><code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span> <span class="pre">POINTER</span></code> argument (15.5.2.7, C.10.4)</li>
</ol>
<p><code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> and other <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> arguments can be passed by simple
address.</p>
<p>Non-F77ish procedures use descriptors to represent two further
kinds of dummy arguments:</p>
<ol class="simple">
<li>assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code></li>
<li>dummy procedures</li>
</ol>
<p>F77ish procedures use other means to convey character length and host instance
links (respectively) for these arguments.</p>
<p>Function results are described by the caller &amp; callee in
a caller-supplied descriptor when they have any of the following
characteristics, some which necessitate an explicit interface:</p>
<ol class="simple">
<li>deferred-shape array (so <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> or <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>)</li>
<li>derived type with any non-constant <code class="docutils literal notranslate"><span class="pre">LEN</span></code> parameter
(C795 prohibit assumed lengths)</li>
<li>procedure pointer result (when the interface must be explicit)</li>
</ol>
<p>Storage for a function call’s result is allocated by the caller when
possible: the result is neither <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> nor <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>,
the shape is scalar or explicit, and the type has <code class="docutils literal notranslate"><span class="pre">LEN</span></code> parameters
that are constant expressions.
In other words, the result doesn’t require the use of a descriptor
but can’t be returned in registers.
This allows a function result to be written directly into a local
variable or temporary when it is safe to treat the variable as if
it were an additional <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> argument.
(Storage for <code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> results, assumed or explicit, is always
allocated by the caller, and the length is always passed so that
an assumed-length external function will work when eventually
called from a scope that declares the length that it will use
(15.5.2.9 (2)).)</p>
<p>Note that the lower bounds of the dimensions of non-<code class="docutils literal notranslate"><span class="pre">POINTER</span></code>
non-<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> dummy argument arrays are determined by the
callee, not the caller.
(A Fortran pitfall: declaring <code class="docutils literal notranslate"><span class="pre">A(0:9)</span></code>, passing it to a dummy
array <code class="docutils literal notranslate"><span class="pre">D(:)</span></code>, and assuming that <code class="docutils literal notranslate"><span class="pre">LBOUND(D,1)</span></code> will be zero
in the callee.)
If the declaration of an assumed-shape dummy argument array
contains an explicit lower bound expression (R819), its value
needs to be computed by the callee;
it may be captured and saved in the incoming descriptor
as long as we assume that argument descriptors can be modified
by callees.
Callers should fill in all of the fields of outgoing
non-<code class="docutils literal notranslate"><span class="pre">POINTER</span></code> non-<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> argument
descriptors with the assumption that the callee will use 1 for
lower bound values, and callees can rely on them being 1 if
not modified.</p>
</div>
<div class="section" id="copying-temporary-storage-back-into-argument-designators">
<span id="copying-temporary-storage-back-into-argument-designators"></span><h3>Copying temporary storage back into argument designators<a class="headerlink" href="#copying-temporary-storage-back-into-argument-designators" title="Permalink to this headline">¶</a></h3>
<p>Except for <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> and known <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> dummy arguments and array sections
with vector-valued subscripts (15.5.2.4(21)), temporary storage into
which effective argument data were compacted for contiguity before the call
must be redistributed back to its original storage by the caller after
the return.</p>
<p>In conjunction with saved cosubscript values, a standard descriptor
would suffice to represent a pointer to the original storage into which the
temporary data should be redistributed;
the descriptor need not be fully populated with type information.</p>
<p>Note that coindexed objects with <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> ultimate components
are required to be associated only with dummy arguments with the
<code class="docutils literal notranslate"><span class="pre">VALUE</span></code> &amp;/or <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> attributes (15.6.2.4(6)), so there is no
requirement that the local image somehow reallocate remote storage
when copying the data back.</p>
</div>
<div class="section" id="polymorphic-bindings">
<span id="polymorphic-bindings"></span><h3>Polymorphic bindings<a class="headerlink" href="#polymorphic-bindings" title="Permalink to this headline">¶</a></h3>
<p>Calls to the type-bound procedures of monomorphic types are
resolved at compilation time, as are calls to <code class="docutils literal notranslate"><span class="pre">NON_OVERRIDABLE</span></code>
type-bound procedures.
The resolution of calls to overridable type-bound procedures of
polymorphic types must be completed at execution (generic resolution
of type-bound procedure bindings from effective argument types, kinds,
and ranks is always a compilation-time task (15.5.6, C.10.6)).</p>
<p>Each derived type that declares or inherits any overridable
type-bound procedure bindings must correspond to a static constant
table of code addresses (or, more likely, a static constant type
description containing or pointing to such a table, along with
information used by the runtime support library for initialization,
copying, finalization, and I/O of type instances).  Each overridable
type-bound procedure in the type corresponds to an index into this table.</p>
</div>
<div class="section" id="host-instance-linkage">
<span id="host-instance-linkage"></span><h3>Host instance linkage<a class="headerlink" href="#host-instance-linkage" title="Permalink to this headline">¶</a></h3>
<p>Calls to dummy procedures and procedure pointers that resolve to
internal procedures need to pass an additional “host instance” argument that
addresses a block of storage in the stack frame of the their
host subprogram that was active at the time they were passed as an
effective argument or associated with a procedure pointer.
This is similar to a static link in implementations of programming
languages with nested subprograms, although Fortran only allows
one level of nesting.
The 64-bit x86 and little-endian OpenPower ABIs reserve registers
for this purpose (<code class="docutils literal notranslate"><span class="pre">%r10</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">R11</span></code>); 64-bit ARM has a reserved register
that can be used (<code class="docutils literal notranslate"><span class="pre">x18</span></code>).</p>
<p>The host subprogram objects that are visible to any of their internal
subprograms need to be resident in memory across any calls to them
(direct or not).  Any host subprogram object that might be defined
during a call to an internal subprogram needs to be reloaded after
a call or reside permanently in memory.
A simple conservative analysis of the internal subprograms can
identify all of these escaping objects and their definable subset.</p>
<p>The address of the host subprogram storage used to hold the escaping
objects needs to be saved alongside the code address(es) that
represent a procedure pointer.
It also needs to be conveyed alongside the text address for a
dummy procedure.</p>
<p>For F77ish procedures, we cannot use a “procedure pointer descriptor”
to pass a procedure argument – they expect to receive a single
address argument.
We will need to package the host instance link in a trampoline
that loads its address into the designated register.</p>
<p>GNU Fortran and Intel Fortran construct trampolines by writing
a sequence of machine instructions to a block of storage in the
host’s stack frame, which requires the stack to be executable,
which seems inadvisable for security reasons;
XLF manages trampolines in its runtime support library, which adds some overhead
to their construction and a reclamation obligation;
NAG Fortran manages a static fixed-sized stack of trampolines
per call site, imposing a hidden limit on recursion and foregoing
reentrancy;
PGI passes host instance links in descriptors in additional arguments
that are not always successfully forwarded across implicit interfaces,
sometimes leading to crashes when they turn out to be needed.</p>
<p>F18 will manage a pool of trampolines in its runtime support library
that can be used to pass internal procedures as effective arguments
to F77ish procedures, so that
a bare code address can serve to represent the effective argument.
But targets that can only be called with an explicit interface
have the option of using a “fat pointer” (or additional argument)
to represent a dummy procedure closure so as
to avoid the overhead of constructing and reclaiming a trampoline.
Procedure descriptors can also support multiple code addresses.</p>
</div>
<div class="section" id="naming">
<span id="naming"></span><h3>Naming<a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h3>
<p>External subroutines and functions (R503) and <code class="docutils literal notranslate"><span class="pre">ENTRY</span></code> points (R1541)
with <code class="docutils literal notranslate"><span class="pre">BIND(C)</span></code> (R808) have linker-visible names that are either explicitly
specified in the program or determined by straightforward rules.
The names of other F77ish external procedures should respect the conventions
of the target architecture for legacy Fortran ‘77 programs; this is typically
something like <code class="docutils literal notranslate"><span class="pre">foo_</span></code>.</p>
<p>In other cases, however, we have fewer constraints on external naming,
as well as some additional requirements and goals.</p>
<p>Module procedures need to be distinguished by the name of their module
and (when they have one) the submodule where their interface was
defined.
Note that submodule names are distinct in their modules, not hierarchical,
so at most two levels of qualification are needed.</p>
<p>Pure <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> functions (15.8) must use distinct names for any alternate
entry points used for packed SIMD arguments of various widths if we support
calls to these functions in SIMD parallel contexts.
There are already conventions for these names in <code class="docutils literal notranslate"><span class="pre">libpgmath</span></code>.</p>
<p>The names of non-F77ish external procedures
should be distinguished as such so that incorrect attempts to call or pass
them with an implicit interface will fail to resolve at link time.
Fortran 2018 explicitly enables us to do this with a correction to Fortran
2003 in 4.3.4(5).</p>
<p>Last, there must be reasonably permanent naming conventions used
by the F18 runtime library for those unrestricted specific intrinsic
functions (table 16.2 in 16.8) and extensions that can be passed as
arguments.</p>
<p>In these cases where external naming is at the discretion
of the implementation, we should use names that are not in the C language
user namespace, begin with something that identifies
the current incompatible version of F18, the module, the submodule, and
elemental SIMD width, and are followed by the external name.
The parts of the external name can be separated by some character that
is acceptable for use in LLVM IR and assembly language but not in user
Fortran or C code, or by switching case
(so long as there’s a way to cope with extension names that don’t begin
with letters).</p>
<p>In particular, the period (<code class="docutils literal notranslate"><span class="pre">.</span></code>) seems safe to use as a separator character,
so a <code class="docutils literal notranslate"><span class="pre">Fa.</span></code> prefix can serve to isolate these discretionary names from
other uses and to identify the earliest link-compatible version.
For examples: <code class="docutils literal notranslate"><span class="pre">Fa.mod.foo</span></code>, <code class="docutils literal notranslate"><span class="pre">Fa.mod.submod.foo</span></code>, and (for an external
subprogram that requires an explicit interface) <code class="docutils literal notranslate"><span class="pre">Fa.foo</span></code>.
When the ABI changes in the future in an incompatible way, the
initial prefix becomes <code class="docutils literal notranslate"><span class="pre">Fb.</span></code>, <code class="docutils literal notranslate"><span class="pre">Fc.</span></code>, &amp;c.</p>
</div>
</div>
<div class="section" id="summary-of-checks-to-be-enforced-in-semantics-analysis">
<span id="summary-of-checks-to-be-enforced-in-semantics-analysis"></span><h2>Summary of checks to be enforced in semantics analysis<a class="headerlink" href="#summary-of-checks-to-be-enforced-in-semantics-analysis" title="Permalink to this headline">¶</a></h2>
<p>8.5.10 <code class="docutils literal notranslate"><span class="pre">INTENT</span></code> attributes</p>
<ul class="simple">
<li>(C846) An <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> argument shall not be associated with an
object that is or has an allocatable coarray.</li>
<li>(C847) An <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> argument shall not have <code class="docutils literal notranslate"><span class="pre">LOCK_TYPE</span></code> or <code class="docutils literal notranslate"><span class="pre">EVENT_TYPE</span></code>.</li>
</ul>
<p>8.5.18 <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> attribute</p>
<ul class="simple">
<li>(C863) The argument cannot be assumed-size, a coarray, or have a coarray
ultimate component.</li>
<li>(C864) The argument cannot be <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>,
<code class="docutils literal notranslate"><span class="pre">INTENT(IN</span> <span class="pre">OUT)</span></code>, or <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code>.</li>
<li>(C865) If the procedure is <code class="docutils literal notranslate"><span class="pre">BIND(C)</span></code>, the argument cannot be <code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code>.</li>
</ul>
<p>15.5.1 procedure references:</p>
<ul class="simple">
<li>(C1533) can’t pass non-intrinsic <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> as argument</li>
<li>(C1536) alternate return labels must be in the inclusive scope</li>
<li>(C1537) coindexed argument cannot have a <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> ultimate component</li>
</ul>
<p>15.5.2.4 requirements for non-<code class="docutils literal notranslate"><span class="pre">POINTER</span></code> non-<code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> dummies:</p>
<ul class="simple">
<li>(2) dummy must be monomorphic for coindexed polymorphic actual</li>
<li>(2) dummy must be polymorphic for assumed-size polymorphic actual</li>
<li>(2) dummy cannot be <code class="docutils literal notranslate"><span class="pre">TYPE(*)</span></code> if effective is PDT or has TBPs or <code class="docutils literal notranslate"><span class="pre">FINAL</span></code></li>
<li>(4) character length of effective cannot be less than dummy</li>
<li>(6) coindexed effective with <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> ultimate component requires
<code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> &amp;/or <code class="docutils literal notranslate"><span class="pre">VALUE</span></code> dummy</li>
<li>(13) a coindexed scalar effective requires a scalar dummy</li>
<li>(14) a non-conindexed scalar effective usually requires a scalar dummy,
but there are some exceptions that allow elements of storage sequences
to be passed and treated like explicit-shape or assumed-size arrays
(see 15.5.2.11)</li>
<li>(16) array rank agreement</li>
<li>(20) <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">INTENT(IN</span> <span class="pre">OUT)</span></code> dummies require definable actuals</li>
<li>(21) array sections with vector subscripts can’t be passed to definable dummies
(<code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code>, <code class="docutils literal notranslate"><span class="pre">INTENT(IN</span> <span class="pre">OUT)</span></code>, <code class="docutils literal notranslate"><span class="pre">ASYNCHRONOUS</span></code>, <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code>)</li>
<li>(22) <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code> attributes must match when dummy has a coarray ultimate component</li>
<li>(C1538 - C1540) checks for <code class="docutils literal notranslate"><span class="pre">ASYNCHRONOUS</span></code> and <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code></li>
</ul>
<p>15.5.2.5 requirements for <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> arguments when both
the dummy and effective arguments have the same attributes:</p>
<ul class="simple">
<li>(2) both or neither can be polymorphic</li>
<li>(2) both are unlimited polymorphic or both have the same declared type</li>
<li>(3) rank compatibility</li>
<li>(4) effective argument must have deferred the same type parameters as the dummy</li>
</ul>
<p>15.5.2.6 <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> dummy arguments:</p>
<ul class="simple">
<li>(2) effective must be <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code></li>
<li>(3) corank must match</li>
<li>(4) coindexed effective requires <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> dummy</li>
<li>(7) <code class="docutils literal notranslate"><span class="pre">INTENT(OUT)</span></code> &amp; <code class="docutils literal notranslate"><span class="pre">INTENT(IN</span> <span class="pre">OUT)</span></code> dummies require definable actuals</li>
</ul>
<p>15.5.2.7 <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> dummy arguments:</p>
<ul class="simple">
<li>(C1541) <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> dummy requires simply contiguous actual</li>
<li>(C1542) effective argument cannot be coindexed unless procedure is intrinsic</li>
<li>(2) effective argument must be <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> unless dummy is <code class="docutils literal notranslate"><span class="pre">INTENT(IN)</span></code> and
effective could be the right-hand side of a pointer assignment statement</li>
</ul>
<p>15.5.2.8 corray dummy arguments:</p>
<ul class="simple">
<li>(1) effective argument must be coarray</li>
<li>(1) <code class="docutils literal notranslate"><span class="pre">VOLATILE</span></code> attributes must match</li>
<li>(2) explicitly or implicitly contiguous dummy array requires a simply contiguous actual</li>
</ul>
<p>15.5.2.9 dummy procedures:</p>
<ul class="simple">
<li>(1) explicit dummy procedure interface must have same characteristics as actual</li>
<li>(5) dummy procedure <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> requirements on effective arguments</li>
</ul>
<p>15.6.2.1 procedure definitions:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">NON_RECURSIVE</span></code> procedures cannot recurse.</li>
<li>Assumed-length <code class="docutils literal notranslate"><span class="pre">CHARACTER(*)</span></code> functions cannot be declared as <code class="docutils literal notranslate"><span class="pre">RECURSIVE</span></code>, array-valued,
<code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code>, or `PURE’ (C723), and cannot be called recursively (15.6.2.1(3)).</li>
<li>(C823) A function result cannot be a coarray or contain a coarray ultimate component.</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">PURE</span></code> requirements (15.7): C1583 - C1599.
These also apply to <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> procedures that are not <code class="docutils literal notranslate"><span class="pre">IMPURE</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> requirements (15.8.1): C15100-C15103,
and C1533 (can’t pass as effective argument unless intrinsic)</p>
<p>For interoperable procedures and interfaces (18.3.6):</p>
<ul class="simple">
<li>C1552 - C1559</li>
<li>function result is scalar and of interoperable type (C1553, 18.3.1-3)</li>
<li><code class="docutils literal notranslate"><span class="pre">VALUE</span></code> arguments are scalar and of interoperable type</li>
<li><code class="docutils literal notranslate"><span class="pre">POINTER</span></code> dummies cannot be <code class="docutils literal notranslate"><span class="pre">CONTIGUOUS</span></code> (18.3.6 paragraph 2(5))</li>
<li>assumed-type dummies cannot be <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code>, <code class="docutils literal notranslate"><span class="pre">POINTER</span></code>, assumed-shape, or assumed-rank (18.3.6 paragraph 2 (5))</li>
<li><code class="docutils literal notranslate"><span class="pre">CHARACTER</span></code> dummies that are <code class="docutils literal notranslate"><span class="pre">ALLOCATABLE</span></code> or <code class="docutils literal notranslate"><span class="pre">POINTER</span></code> must be deferred-length</li>
</ul>
</div>
<div class="section" id="further-topics-to-document">
<span id="further-topics-to-document"></span><h2>Further topics to document<a class="headerlink" href="#further-topics-to-document" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li>Alternate return specifiers</li>
<li><code class="docutils literal notranslate"><span class="pre">%VAL()</span></code>, <code class="docutils literal notranslate"><span class="pre">%REF()</span></code>, and <code class="docutils literal notranslate"><span class="pre">%DESCR()</span></code> legacy VMS interoperability extensions</li>
<li>Unrestricted specific intrinsic functions as effective arguments</li>
<li>SIMD variants of <code class="docutils literal notranslate"><span class="pre">ELEMENTAL</span></code> procedures (&amp; unrestricted specific intrinsics)</li>
<li>Elemental subroutine calls with array arguments</li>
</ul>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="Character.html" title="Implementation of CHARACTER types in f18"
             >next</a> |</li>
        <li class="right" >
          <a href="RuntimeDescriptor.html" title="Runtime Descriptors"
             >previous</a> |</li>
<! TODO: Change the webpage  >
  <li><a href="https://flang.llvm.org">Flang Home</a>&nbsp;|&nbsp;</li>
  <li><a href="index.html">Documentation</a>&raquo;</li>
 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017-2021, The Flang Team.
      Last updated on Apr 01, 2021.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.8.5.
    </div>
  </body>
</html>